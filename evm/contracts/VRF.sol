pragma solidity 0.4.24;

// Inputs will now be seed, PK, c, s, gamma, uAddress, vAddress. We'll compute
// h, the hash to the curve of seed, then check that uAddress is the address for
// c*PK+s*g, and vAddress is the address for c*gamma+s*h, and finally that c =
// Hash(g, h, PK, gamma, u, v).

// It's necessary to provide c*PK, its address, s*g and its address. These can
// be checked by the ECRECOVER trick, and then c*PK+s*g must be computed in
// solidity unfortunately. I'm copying that from the email I sent HarryR.

/* VRF implements on-chain verification of verifiable-random-function (VRF)
 * proofs, as described in these documents:
 * https://tools.ietf.org/html/draft-goldbe-vrf-01#section-5 (spec)
 * https://eprint.iacr.org/2017/099.pdf (security proofs).
 *
 * Purpose
 * -------
 *
 * Reggie the Random Oracle (not his real job) wants to provide randomness to
 * Vera the verifier in such a way that Vera can be sure he's not making his
 * output up to suit himself. Reggie provides Vera a public key to which he
 * knows the secret key. Each time Vera provides a seed to Reggie, he gives back
 * a value which is computed completely deterministically from the seed and the
 * secret key, but which is indistinguishable from randomness to Vera.
 * Nonetheless, Vera is able to verify that Reggie's output came from her seed
 * and his secret key.
 *
 * The purpose of this contract is to perform that verification.
 *
 * Usage
 * -----
 *
 * The main entry point is isValidVRFOutput. Pass it the fields of a vrf.Proof
 * object generated by vrf.go/GenerateProof.
 *
 * Returns true iff the proof can be verified as showing that _output was
 * generated as mandated.
 *
 * See the invocation of verifyVRFProof in VRF.js, for an example.
 *
 * Design notes
 * ------------
 *
 * An elliptic curve point is generally represented in the solidity code as a
 * uint256[2], corresponding to its affine coordinates in GF(fieldSize).
 *
 * For the sake of efficiency, this implementation deviates from the spec in
 * some minor ways:
 *
 * - Keccak hash rather than SHA256. This is because it's provided natively by
 *   the EVM, and therefore costs much less gas. The impact on security should
 *   be minor.
 *
 * - Secp256k1 curve instead of P-256. It abuses ECRECOVER for the ECC
 *   arithmetic, which would mitigate this weakness.
 *
 * - scalarFromCurve recursively hashes and takes the relevant hash bits until
 *   it finds a point less than the group order. This results in uniform
 *   sampling over the the possible values scalarFromCurve could take. The spec
 *   recommends just uing the first hash output as a uint256, which is a
 *   slightly biased sample. See the zqHash function.
 *
 * - hashToCurve recursively hashes until it finds a curve x-ordinate. The spec
 *   recommends that the initial input should be concatenated with a nonce and
 *   then hashed, and this input should be rehashed with the nonce updated until
 *   an x-ordinate is found. Recursive hashing is slightly more efficient. The
 *   spec also recommends (https://tools.ietf.org/html/rfc8032#section-5.1.3 ,
 *   by the specification of RS2ECP) that the x-ordinate should be rejected if
 *   it is greater than the modulus.
 *
 *   The spec also requires the y ordinate of the hashToCurve to be negated if y
 *   is odd. See http://www.secg.org/sec1-v2.pdf#page=17 . This appears to be
 *   purely for compositional purposes: They need to specify some way to
 *   determine y given x, and happened to pick that one. Here, y is determined
 *   as (x^3+3)^{(p+1)/4, instead.}
 *
 */

import "openzeppelin-solidity/contracts/math/SafeMath.sol";

contract VRF {

  using SafeMath for uint256;

  // Prime characteristic of the galois field over which the curve is defined
  uint256 constant GROUP_ORDER =
    // solium-disable-next-line indentation
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;
  // solium-disable-next-line zeppelin/no-arithmetic-operations
  uint256 constant public HALF_GROUP_ORDER = (Q >> 1) + 1;
  uint256 constant FIELD_SIZE =
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;

  uint256 constant MINUS_ONE = FIELD_SIZE.sub(1);
  uint256 constant MULTIPLICATIVE_GROUP_ORDER = FIELD_SIZE.sub(1);
  uint256 constant EULERS_CRITERION_POWER = multiplicativeGroupOrder.div(2);
  // pow(x, SQRT_POWER, FIELD_SIZE) == ‚àöx, since FIELD_SIZE % 4 = 3
  uint256 constant SQRT_POWER = FIELD_SIZE.add(1).div(4); 

  uint256 constant WORD_LENGTH_BYTES = 0x20;

  // (_base**_exponent) % _modulus
  // Cribbed from https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4
  function bigModExp(uint256 _base, uint256 _exponent, uint256 _modulus)
    public view returns (uint256 exponentiation) {
    uint256 callResult;
    uint256[6] memory bigModExpContractInputs;
    bigModExpContractInputs[0] = WORD_LENGTH_BYTES;  // Length of _base
    bigModExpContractInputs[1] = WORD_LENGTH_BYTES;  // Length of _exponent
    bigModExpContractInputs[2] = WORD_LENGTH_BYTES;  // Length of _modulus
    bigModExpContractInputs[3] = _base;
    bigModExpContractInputs[4] = _exponent;
    bigModExpContractInputs[5] = _modulus;
    uint256[1] memory output;
    assembly {
      callResult :=
        staticcall(not(0),                   // Let bigmodexp use arbitrary gas
                   0x05,                     // Bigmodexp contract address
                   bigModExpContractInputs,
                   0xc0,                     // Length of input segment
                   output,
                   0x20)                     // Length of output segment
      }
    if (callResult == 0) {revert("bigModExp failure!");}
    return output[0];
  }

  // True iff _x = a^2 for some a in base Galois field (per Euler criterion.)
  function isSquare(uint256 _x) public view returns (bool) {
    uint256 halfFermatExponentiation = bigModExp(
      _x, EULERS_CRITERION_POWER, FIELD_SIZE);
    assert((halfFermatExponentiation == 1) ||
           (halfFermatExponentiation == MINUS_ONE));
    return (halfFermatExponentiation == 1);
  }

  // Computes a s.t. a^2 = _x in the field. Assumes _x is a square.
  function squareRoot(uint256 _x) public view returns (uint256) {
    return bigModExp(_x, SQRT_POWER, FIELD_SIZE);
  }

  function ySquared(uint256 _x) public view returns (uint256) {
    // Curve equation is y^2=_x^3+3. See
    // github.com/ethereum/go-ethereum/blob/1636d957/crypto/bn256/cloudflare/curve.go#L39
    return bigModExp(_x, 3, FIELD_SIZE).add(3) % FIELD_SIZE;
  }

  // True iff there is y s.t. (y^2 % FIELD_SIZE) = (_x^3+3 % FIELD_SIZE)
  function isCurveXOrdinate(uint256 _x) public view returns (bool) {
    return isSquare(ySquared(_x));
  }

  // True iff _x is a sane value for an ECDSA signature. We need to check this
  // to

  // Hash _x uniformly into {0, ..., q-1}. Assumes bitlength of q is 254
  // Expects _x to *already* have the necessary entropy... If _x < q, returns _x!
  function zqHash(uint256 q, uint256 _x) public pure returns (uint256 x) {
    x = _x & orderMask;
    while (x >= q) {x = uint256(keccak256(abi.encodePacked(x))) & orderMask;}
  }

  // One-way hash function onto the curve.
  function hashToCurve(uint256[2] memory _k, uint256 _input)
    public view returns (uint256[2] memory rv) {
    bytes32 hash = keccak256(abi.encodePacked(_k[0], _k[1], _input));
    rv[0] = zqHash(FIELD_SIZE, uint256(hash));
    while  (!isCurveXOrdinate(rv[0])) {
      rv[0] = zqHash(FIELD_SIZE, uint256(keccak256(abi.encodePacked(rv[0]))));
    }
    rv[1] = squareRoot(ySquared(rv[0]));
  }

  // Following explicit elliptic-curve arithmetic is taken from HarryR's
  // solcrypto library. https://github.com/HarryR/solcrypto

  // Returns the address associated with c*R. See
  // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9
  // The point corresponding to the address returned by ecrecover(0,v,r,s=c*r)
  // is (r‚Åª¬π mod Q) * (c*r * R - 0 * g) = c * R, where R is the point
  // specified by (v, r). See https://crypto.stackexchange.com/a/18106
  function scalar_mult_address(uint256[2] memory R, uint256 c)
    internal pure returns(address) {
    return ecrecover(bytes32(0),                   // message hash of 0
                     R[1] % 2 != 0 ? 28 : 27,      // v
                     bytes32(R[0]),                // r
                     bytes32(mulmod(c, R[0], Q))); // s = c * r
  }

  // Bits used in Ethereum address
  uint256 constant public BOTTOM_160_BITS = 2**161 - 1;

  // Returns the ethereum address associated with point.
  function point_address(uint256[2] memory point)
    internal pure returns(address) {
    // Lower 160 bits of the keccak hash of (x,y) as 64 bytes
    return address(uint256(keccak256(abi.encodePacked(point))) &
                   BOTTOM_160_BITS);
  }

  // Returns true iff q==scalar*x, with cryptographically high probability.
  // Based on Vitalik Buterin's idea in above ethresear.ch post.
  function ecmulVerify(uint256[2] memory x, uint256 scalar, uint256[2] memory q)
    internal pure returns(bool) {
    // See scalar_mult_address and point_address for explanation. We inline here
    // to save gas
    return ecrecover(bytes32(0), x[1] % 2 != 0 ? 28 : 27,
                     bytes32(x[0]), bytes32(mulmod(scalar, x[0], Q))) ==
      address(uint256(keccak256(abi.encodePacked(q))) & BOTTOM_160_BITS);
  }

  // Returns x1/z1+x2/z2=(x1z2+x2z1)/(z1z2) in projective coordinates on P¬π(ùîΩ‚Çô)
  function projectiveAdd(uint256 x1, uint256 z1, uint256 x2, uint256 z2)
    internal pure returns(uint256 x3, uint256 z3) {
    require(x1 != 0 || z1 != 0,
            "at least one projective cooordinate must be nonzero");
    require(x2 != 0 || z2 != 0,
            "at least one projective cooordinate must be nonzero");
    (x3, z3) = (addmod(mulmod(z2, x1, FIELD_SIZE),
                       mulmod(x2, z1, FIELD_SIZE), FIELD_SIZE),
                mulmod(z1, z2, FIELD_SIZE));
  }

  // Returns x1/z1-x2/z2=(x1z2+x2z1)/(z1z2) in projective coordinates on P¬π(ùîΩ‚Çô)
  function projectiveSub(uint256 x1, uint256 z1, uint256 x2, uint256 z2) 
    internal pure returns(uint256 x3, uint256 z3) {
    require(x1 != 0 || z1 != 0,
            "at least one projective cooordinate must be nonzero");
    require(x2 != 0 || z2 != 0,
            "at least one projective cooordinate must be nonzero");
    (x3, z3) = (addmod(mulmod(z2, x1, FIELD_SIZE),
                       mulmod(FIELD_SIZE - x2, z1, FIELD_SIZE), FIELD_SIZE),
                mulmod(z1, z2, FIELD_SIZE));
  }

  // Returns x1/z1*x2/z2=(x1x2)/(z1z2), in projective coordinates on P¬π(ùîΩ‚Çô)
  function projectiveMul(uint256 x1, uint256 z1, uint256 x2, uint256 z2)
    internal pure returns(uint256 x3, uint256 z3) {
    require(x1 != 0 || z1 != 0,
            "at least one projective cooordinate must be nonzero");
    require(x2 != 0 || z2 != 0,
            "at least one projective cooordinate must be nonzero");
    (x3, z3) = (mulmod(x1, x2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));
  }

  // Returns x1/z1/(x2/z2)=(x1z2)/(x2z1), in projective coordinates on P¬π(ùîΩ‚Çô)
  function projectiveDiv(uint256 x1, uint256 z1, uint256 x2, uint256 z2)
    internal pure returns(uint256 x3, uint256 z3) {
    require(x1 != 0 || z1 != 0,
            "at least one projective cooordinate must be nonzero");
    require(x2 != 0 || z2 != 0,
            "at least one projective cooordinate must be nonzero");
    (x3, z3) = (mulmod(x1, z2, FIELD_SIZE), mulmod(z1, x2, FIELD_SIZE));
  }

  // Returns true iff [x,y,z] is a point on secp256k1, in P¬≤(ùîΩ‚Çô)
  function projectiveIsOnCurve(uint256 x, uint256 y, uint256 z)
    internal pure returns (bool) {
    // zy^2 == x^3 + 7z^3 (homogenization of usual secp256k1 equation)
    return mulmod(z, mulmod(y, y, FIELD_SIZE), FIELD_SIZE) == // zy^2
      addmod(mulmod(x, mulmod(x, x, FIELD_SIZE), FIELD_SIZE), // x^3
             mulmod(7, mulmod(z, mulmod(z, z, FIELD_SIZE), FIELD_SIZE), // 7z^3
                    FIELD_SIZE), FIELD_SIZE); 
  }

  // Returns [x1,y1,z1]+[x2,y2,z2] as points on secp256k1, in P¬≤(ùîΩ‚Çô)
  function projectiveECAdd(uint256 x1, uint256 y1, uint256 z1, uint256 x2,
                           uint256 y2, uint256 z2)
    internal pure returns(uint256 x3, uint256 y3, uint256 z3) {
    require(x1 != 0 || y1 != 0 || z1 != 0,
            "at least one projective cooordinate must be nonzero");
    require(x2 != 0 || y2 != 0 || z2 != 0,
            "at least one projective cooordinate must be nonzero");
    require(projectiveIsOnCurve(x1, y1, z1), "point must be on secp256k1");
    require(projectiveIsOnCurve(x2, y2, z2), "point must be on secp256k1");
    // See "Group law for E/K : y^2 = x^3 + ax + b", in section 3.1.2, p. 80,
    // "Guide to Elliptic Curve Cryptography" by Hankerson, Menezes and Vanstone
    // We take the equations there for (x3,y3), and homogenize them to
    // projective coordinates. That way, no inverses are required, here, and we
    // only need the one inverse in affineECAdd.
    uint256 lx; uint256 lz; // Numerator for base of first term: The slope.
    uint256 da; uint256 db; // Accumulates factors in denominator
    if (x1 == 0 && y1 == 0) { // P1 is point at infinity (the zero of the group)
      return (x2, y2, z2); // 0 + P2 = P2
    }
    if (x2 == 0 && y2 == 0) { // P2 is point at infinity (the zero of the group)
      return (x1, y1, z1); // P1 + 0 = P1
    }
    if (x1 == x2 && y1 == y2) {
      // Corresponds to "4. Point doubling" equations, in Hankerson et al.
      // (lx, lz) / (da, db) = (3x1^2+a)/(2y1), i.e., gradient of tangent line.
      (lx, lz) = projectiveMul(x1, z1, x1, z1); // Ends up with 3x1^2+a
      (lx, lz) = projectiveMul(lx, lz, 3, 1);
      // (lx, lz) = projectiveAdd(lx, lz, a, 1); // No-op, since a=0
      (da, db) = projectiveMul(y1, z1, 2, 1); // 2*y1
    } else {
      // Corresponds to "3. Point addition" equations, in Hankerson, et al.
      // (lx, lz) / (da, db) = (y2-y1)/(x2-x1), i.e., gradient of secant line.
      (lx, lz) = projectiveSub(y2, z2, y1, z1); // y2-y1
      (da, db) = projectiveSub(x2, z2, x1, z1); // x2-x1
    }
    (lx, lz) = projectiveDiv(lx, lz, da, db); // Contains first term

    // x3=((3x1^2+a)/(2y1))^2-2x1 for doubling, ((y2-y1)/(x2-x1))^2-x1-x2 for
    // addition
    (x3, da) = projectiveMul(lx, lz, lx, lz); // Base is squared for x3 equation
    (x3, da) = projectiveSub(x3, da, x1, z1); // Then subtract x1 and x2
    (x3, da) = projectiveSub(x3, da, x2, z2);

    // y3=(3x1^2+a/(2y1))(x1-x3)-y1 for doubling, ((y2-y1)/(x2-x1))(x1-x3)-y2
    // for addition
    //
    // Base is multiplied by x1-x3, for y3 equation
    (y3, db) = projectiveSub(x1, z1, x3, da); 
    (y3, db) = projectiveMul(y3, db, lx, lz);
    (y3, db) = projectiveSub(y3, db, y1, z1); // Then subtract y1

    if (da != db) { // Put everything over a common denominator
      x3 = mulmod(x3, db, FIELD_SIZE);
      y3 = mulmod(y3, da, FIELD_SIZE);
      z3 = mulmod(da, db, FIELD_SIZE);
    } else {
      z3 = da;
    }
  }

  // returns p1+p2, as affine points on secp256k1. _invZ must be the inverse of
  // the z returned by projectiveECAdd(_p1, _p2)
  function affineECAdd(uint256[2] memory _p1, uint256[2] memory _p2,
                       uint256 _invZ)
    internal view returns (uint256[2] memory) {
    uint256 x; uint256 y; uint256 z;
    (x, y, z) = projectiveECAdd(p1[0], p1[1], 1, p2[0], p2[1], 1);
    require(mulmod(z * _invZ, FIELD_SIZE) == 1,
            "_invZ must be the inverse of ");
    // Clear the z ordinate of the projective representation by dividing through
    // by it, to obtain the affine representation
    return [mulmod(x, _invZ, FIELD_SIZE), mulmod(y, _invZ, FIELD_SIZE)];
  }

  // Returns true iff address(_c*_p+_s*g) == _lcWitness, where g is generator.
  // Only works if 
  function verifyLinearCombinationWithGenerator(uint256 _c,
                                                uint256[2] memory _p,
                                                uint256 _s,
                                                address _lcWitness)
    public pure returns (address) {
    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9
    // The point corresponding to the address returned by
    // ecrecover(-_s*_p[0],v,_p[0],_c*_p[0]) is
    // (_p[0]‚Åª¬π mod FIELD_SIZE)*(_c*_p[0]*_p-(-_s)*_p[0]*g)=_c*_p+_s*g, where v
    // is the parity of _p[1]. See https://crypto.stackexchange.com/a/18106
    bytes32 pseudoHash = bytes32(FIELD_SIZE - mulmod(_p[0], _s, FIELD_SIZE));
    // https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v
    uint256 v = (_p[1] % 2 == 0) ? 27 : 28;
    bytes32 pseudoSignature = bytes32(mulmod(_c, _p[0]), FIELD_SIZE);
    address computed = ecrecover(pseudoHash, v, _p[0], pseudoSignature);
    return computed == _lcWitness;
  }

  // _c*_p1 + _s*_p2
  function linearCombination(uint256 _c, uint256[2] memory _p1,
                             uint256[2] memory _cp1Witness,
                             uint256 _s, uint256[2] memory _p2,
                             uint256[2] memory _sp2Witness, uint256 _zInv)
    public view returns (uint256[2] memory) {
    require(ecmulVerify(_p1, _c, _cp1Witness),
            "First multiplication check failed");
    require(ecmulVerify(_p2, _s, _sp2Witness),
            "Second multiplication check failed");
    return affineECAdd(_cp1Witness, _sp2Witness, _zInv);
  }

  // Pseudo-random number from inputs. Corresponds to vrf.go/scalarFromCurve.
  function scalarFromCurve(uint256[2] memory _hash, uint256[2] memory _pk,
                           uint256[2] memory _gamma, uint256[2] memory _u,
                           uint256[2] memory _v)
    public view returns (uint256 s) {
    bytes32 iHash = keccak256(abi.encodePacked(generator, _hash, _pk, _gamma,
                                               _u, _v));
    return zqHash(GROUP_ORDER, uint256(iHash));
  }

  // True if (gamma, c, s) is a correctly constructed randomness proof from _pk
  // and _seed
  function verifyVRFProof(uint256[2] memory _pk,
                          uint256[2] memory _gamma,
                          uint256 _c, uint256 _s, uint256 _seed,
                          address uWitness,
                          uint256[2] memory _cGammaWitness,
                          uint256[2] memory _sGeneratorWitness)
    public view returns (bool) {
    // NB: Curve operations already check that (_pkX, _pkY), (_gammaX, _gammaY)
    // are valid curve points. No need to do that explicitly.
    uint256[2] memory u = verifyLinearCombinationWithGenerator(_c, _pk,
                                                               _s, generator);
    uint256[2] memory hash = hashToCurve(_pk, _seed);
    uint256[2] memory v = linearCombination(_c, _gamma, _s, hash);
    return (_c == scalarFromCurve(hash, _pk, _gamma, u, v));
  }

  // True if _output is correct VRF output given other parameters
  function isValidVRFOutput(uint256[2] memory _pk, uint256[2] memory _gamma,
                            uint256 _c, uint256 _s, uint256 _seed,
                            uint256 _output)
    public view returns (bool) {
    return verifyVRFProof(_pk, _gamma, _c, _s, _seed) &&
      (uint256(keccak256(abi.encodePacked(_gamma))) == _output);
  }
}
